# Sets

![alt text](./Imagens/dicionario.png)

Conhecidos tamb√©m como HashMaps ou Arrays Associativos os dicion√°rios s√£o um misto entre o set e list e com certeza a estutura de dados mais importante da linguagem.


## Vamos entender para que servem os dicion√°rios com este exemplo usando tipos prim√°rios.

```
produto_nome = "Caneta"
produto_cor1 = "azul"
produto_cor2 = "branco"
produto_preco = 3.23
produto_dimensao_altura = 12.1
produto_dimensao_largura = 0.8
produto_em_estoque = True
produto_codigo = 45678
produto_codebar = None
```
Acima estamos representando um √∫nico produto em um programa de vendas, √© uma √∫nica caneta por√©m precisamos de 9 objetos de diferentes tipos.

E para resolver este problema que temos os tipos compostos, eles s√£o containeres, objetos que podem agrupar mais de um tipo e mais de uma unidade de informa√ß√£o dentro deles.

Dicion√°rios s√£o criados com { } ou atrav√©s da classe dict(), √© bom ter cuidado para n√£o os confundir com sets j√° que sets tamb√©m usam { } e a diferen√ßa principal √© o fato de que no set cada posi√ß√£o armazena apenas um valor e nos dicion√°rios podemos colocar 2 valores em cada posi√ß√£o.

Um desses valores √© chamado de chave key e o outro valor val e s√£o separados por :, veja com um dicion√°rio a mesma informa√ß√£o pode ser representada com:

```
produto = {
	"nome": "Caneta",
	"cor1": "azul",
	"cor2": "branco",
	"preco": 3.23,
	"dimensao_altura": 12.1,
	"dimensao_largura":  0.8,
	"em_estoque": True,
	"codigo": 45678,
	"codebar": None,
}
```
Agora temos um √∫nico objeto produto do tipo dict e isso torna nosso programa muito melhor organizado, facilita opera√ß√µes e deixa a complexidade menor tamb√©m pois os dicion√°rios assim como os sets tamb√©m implementam a Hash Table, ou seja, as opera√ß√£o de acesso s√£o O(1) super r√°pidas.

Assim como as listas os dicion√°rios podem receber subscri√ß√µes a partir de uma chave, ou seja, usamos [] e dentro passamos a key que queremos acessar.

Al√©m disso podemos diminuir a redundancia colocando objetos compostos dentro do dicin√°rio, ao inv√©s de 2 chaves para representar cor podemos criar uma lista de cores e ao inv√©s de 2 chaves para dimensoes podemos ter um subdicion√°rio.

```
produto = {
	"nome": "Caneta",
	"cores": ["azul", "branco"],
	"preco": 3.23,
	"dimensao" {
        "altura": 12.1,
	    "largura":  0.8,
    },
	"em_estoque: True,
	"codigo": 45678,
	"codebar": None,
}
```
## Sintaxe

Podemos iniciar um dicion√°rio vazio e depois ir adicionando elementos dentro dele.

```
cliente = {}
# ou
cliente = dict()
```

## CRUD

E usar as opera√ß√µes de CRUD (Create, Read, Update, Delete)

Criar - Adicionar chave+valor
```
cliente["nome"] = "Bruno"
```
Ler valor a partir de uma chave
```
>>> cliente["nome"]
'Bruno'
```
Update - Alterar valor a partir de uma chave
```
cliente["nome"] = "Bruno Rocha"
```
Delete - Remover um valor e sua chave.
```
del cliente["nome"]
```

## Buscas

O dicion√°rio implementa Hash Table, ele tamb√©m √© conhecido como hash map e portanto as buscas em dicion√°rio quando feitas por chave tem acesso constante O(1).
```
"nome" in cliente
True
```
in invoca o protocolo Lookupable atrav√©s do m√©todo __contains__ e efetua a busca imediata sem necessidade de iterar todo o dicion√°rio para encontrar uma chave, e assim como os sets as chaves n√£o podem se repetir.

## Erros

Caso uma chave n√£o exista no dicion√°rio o Python estoura um erro chamado KeyError
```
print(cliente["telefone"])
...
KeyError 'telefone'
```
Para evitar o erro podemos usar o m√©todo get que busca a chave e caso n√£o exista retorna um valor padr√£o que inicialmente √© None
```
print(cliente.get("telefone"))
'None'

print(cliente.get("telefone", "191"))
'191'
```

‚å®Ô∏è com ‚ù§Ô∏è por [Elias Assun√ß√£o](https://github.com/Hooligam) üî•
